"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[176],{3176:function(t,e,i){i.r(e),i.d(e,{FilesystemWeb:function(){return FilesystemWeb}});var r=i(9895),a=i(4963);function resolve(t){let e=t.split("/").filter(t=>"."!==t),i=[];return e.forEach(t=>{".."===t&&i.length>0&&".."!==i[i.length-1]?i.pop():i.push(t)}),i.join("/")}let FilesystemWeb=class FilesystemWeb extends r.Uw{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async t=>{var e,i;let a;let s=(0,r.Sd)(t,t.webFetchExtra),o=await fetch(t.url,s);if(t.progress){if(null==o?void 0:o.body){let e=o.body.getReader(),i=0,r=[],s=o.headers.get("content-type"),n=parseInt(o.headers.get("content-length")||"0",10);for(;;){let{done:a,value:s}=await e.read();if(a)break;r.push(s),i+=(null==s?void 0:s.length)||0;let o={url:t.url,bytes:i,contentLength:n};this.notifyListeners("progress",o)}let d=new Uint8Array(i),h=0;for(let t of r)void 0!==t&&(d.set(t,h),h+=t.length);a=new Blob([d.buffer],{type:s||void 0})}else a=new Blob}else a=await o.blob();let n=await this.writeFile({path:t.path,directory:null!==(e=t.directory)&&void 0!==e?e:void 0,recursive:null!==(i=t.recursive)&&void 0!==i&&i,data:a});return{path:n.uri,blob:a}}}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((t,e)=>{let i=indexedDB.open(this.DB_NAME,this.DB_VERSION);i.onupgradeneeded=FilesystemWeb.doUpgrade,i.onsuccess=()=>{this._db=i.result,t(i.result)},i.onerror=()=>e(i.error),i.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(t){let e=t.target,i=e.result;t.oldVersion;{i.objectStoreNames.contains("FileStorage")&&i.deleteObjectStore("FileStorage");let t=i.createObjectStore("FileStorage",{keyPath:"path"});t.createIndex("by_folder","folder")}}async dbRequest(t,e){let i=-1!==this._writeCmds.indexOf(t)?"readwrite":"readonly";return this.initDb().then(r=>new Promise((a,s)=>{let o=r.transaction(["FileStorage"],i),n=o.objectStore("FileStorage"),d=n[t](...e);d.onsuccess=()=>a(d.result),d.onerror=()=>s(d.error)}))}async dbIndexRequest(t,e,i){let r=-1!==this._writeCmds.indexOf(e)?"readwrite":"readonly";return this.initDb().then(a=>new Promise((s,o)=>{let n=a.transaction(["FileStorage"],r),d=n.objectStore("FileStorage"),h=d.index(t),l=h[e](...i);l.onsuccess=()=>s(l.result),l.onerror=()=>o(l.error)}))}getPath(t,e){let i=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"",r="";return void 0!==t&&(r+="/"+t),""!==e&&(r+="/"+i),r}async clear(){let t=await this.initDb(),e=t.transaction(["FileStorage"],"readwrite"),i=e.objectStore("FileStorage");i.clear()}async readFile(t){let e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);if(void 0===i)throw Error("File does not exist.");return{data:i.content?i.content:""}}async writeFile(t){let e=this.getPath(t.directory,t.path),i=t.data,r=t.encoding,a=t.recursive,s=await this.dbRequest("get",[e]);if(s&&"directory"===s.type)throw Error("The supplied path is a directory.");let o=e.substr(0,e.lastIndexOf("/")),n=await this.dbRequest("get",[o]);if(void 0===n){let e=o.indexOf("/",1);if(-1!==e){let i=o.substr(e);await this.mkdir({path:i,directory:t.directory,recursive:a})}}if(!r&&!(i instanceof Blob)&&(i=i.indexOf(",")>=0?i.split(",")[1]:i,!this.isBase64String(i)))throw Error("The supplied data is not valid base64 content.");let d=Date.now(),h={path:e,folder:o,type:"file",size:i instanceof Blob?i.size:i.length,ctime:d,mtime:d,content:i};return await this.dbRequest("put",[h]),{uri:h.path}}async appendFile(t){let e=this.getPath(t.directory,t.path),i=t.data,r=t.encoding,a=e.substr(0,e.lastIndexOf("/")),s=Date.now(),o=s,n=await this.dbRequest("get",[e]);if(n&&"directory"===n.type)throw Error("The supplied path is a directory.");let d=await this.dbRequest("get",[a]);if(void 0===d){let e=a.indexOf("/",1);if(-1!==e){let i=a.substr(e);await this.mkdir({path:i,directory:t.directory,recursive:!0})}}if(!r&&!this.isBase64String(i))throw Error("The supplied data is not valid base64 content.");if(void 0!==n){if(n.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");i=void 0===n.content||r?n.content+i:btoa(atob(n.content)+atob(i)),o=n.ctime}let h={path:e,folder:a,type:"file",size:i.length,ctime:o,mtime:s,content:i};await this.dbRequest("put",[h])}async deleteFile(t){let e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);if(void 0===i)throw Error("File does not exist.");let r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]);if(0!==r.length)throw Error("Folder is not empty.");await this.dbRequest("delete",[e])}async mkdir(t){let e=this.getPath(t.directory,t.path),i=t.recursive,r=e.substr(0,e.lastIndexOf("/")),a=(e.match(/\//g)||[]).length,s=await this.dbRequest("get",[r]),o=await this.dbRequest("get",[e]);if(1===a)throw Error("Cannot create Root directory");if(void 0!==o)throw Error("Current directory does already exist.");if(!i&&2!==a&&void 0===s)throw Error("Parent directory must exist");if(i&&2!==a&&void 0===s){let e=r.substr(r.indexOf("/",1));await this.mkdir({path:e,directory:t.directory,recursive:i})}let n=Date.now();await this.dbRequest("put",[{path:e,folder:r,type:"directory",size:0,ctime:n,mtime:n}])}async rmdir(t){let{path:e,directory:i,recursive:r}=t,a=this.getPath(i,e),s=await this.dbRequest("get",[a]);if(void 0===s)throw Error("Folder does not exist.");if("directory"!==s.type)throw Error("Requested path is not a directory");let o=await this.readdir({path:e,directory:i});if(0!==o.files.length&&!r)throw Error("Folder is not empty");for(let t of o.files){let a=`${e}/${t.name}`,s=await this.stat({path:a,directory:i});"file"===s.type?await this.deleteFile({path:a,directory:i}):await this.rmdir({path:a,directory:i,recursive:r})}await this.dbRequest("delete",[a])}async readdir(t){let e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);if(""!==t.path&&void 0===i)throw Error("Folder does not exist.");let r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]),a=await Promise.all(r.map(async t=>{let i=await this.dbRequest("get",[t]);return void 0===i&&(i=await this.dbRequest("get",[t+"/"])),{name:t.substring(e.length+1),type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}}));return{files:a}}async getUri(t){let e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);return void 0===i&&(i=await this.dbRequest("get",[e+"/"])),{uri:(null==i?void 0:i.path)||e}}async stat(t){let e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);if(void 0===i&&(i=await this.dbRequest("get",[e+"/"])),void 0===i)throw Error("Entry does not exist.");return{type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}}async rename(t){await this._copy(t,!0)}async copy(t){return this._copy(t,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(t,e=!1){let i,{toDirectory:r}=t,{to:s,from:o,directory:n}=t;if(!s||!o)throw Error("Both to and from must be provided");r||(r=n);let d=this.getPath(n,o),h=this.getPath(r,s);if(d===h)return{uri:h};if(function(t,e){t=resolve(t),e=resolve(e);let i=t.split("/"),r=e.split("/");return t!==e&&i.every((t,e)=>t===r[e])}(d,h))throw Error("To path cannot contain the from path");try{i=await this.stat({path:s,directory:r})}catch(i){let t=s.split("/");t.pop();let e=t.join("/");if(t.length>0){let t=await this.stat({path:e,directory:r});if("directory"!==t.type)throw Error("Parent directory of the to path is a file")}}if(i&&"directory"===i.type)throw Error("Cannot overwrite a directory with a file");let l=await this.stat({path:o,directory:n}),updateTime=async(t,e,i)=>{let a=this.getPath(r,t),s=await this.dbRequest("get",[a]);s.ctime=e,s.mtime=i,await this.dbRequest("put",[s])},c=l.ctime?l.ctime:Date.now();switch(l.type){case"file":{let t;let i=await this.readFile({path:o,directory:n});e&&await this.deleteFile({path:o,directory:n}),i.data instanceof Blob||this.isBase64String(i.data)||(t=a.ez.UTF8);let d=await this.writeFile({path:s,directory:r,data:i.data,encoding:t});return e&&await updateTime(s,c,l.mtime),d}case"directory":{if(i)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:s,directory:r,recursive:!1}),e&&await updateTime(s,c,l.mtime)}catch(t){}let t=(await this.readdir({path:o,directory:n})).files;for(let i of t)await this._copy({from:`${o}/${i.name}`,to:`${s}/${i.name}`,directory:n,toDirectory:r},e);e&&await this.rmdir({path:o,directory:n})}}return{uri:h}}isBase64String(t){try{return btoa(atob(t))==t}catch(t){return!1}}};FilesystemWeb._debug=!0}}]);